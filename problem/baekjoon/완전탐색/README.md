## 완전탐색
### 완전탐색 방법
1. Brute Force
2. 비트마스크
   - 비트 이동 연산자 (<<, >>, >>>)
     - x << y
       - 정수 x의 각 비트를 y만큼 왼쪽으로 이동시킴 (빈자리는 0으로 채워짐).
     - x >> y
       - 정수 x의 각 비트를 y만큼 오른쪽으로 이동시킴 (빈자리는 정수 x의 최상위 부호 비트와 같은 값으로 채워짐).
     - x >>> y
       - 정수 x의 각 비트를 y만큼 오른쪽으로 이동시킴 (빈자리는 0으로 채워짐).
   - 비트 논리 연산자 (&, |, ^, ~)
     - ~ (보수)
       - 이진수로 표현된 피연산자의 값을 반전(보수)시켜주어 표현함.
   - 집합 구현
     - 하나의 비트가 하나의 원소를 표현하며, N비트 정수 변수라면 N개의 원소를 갖는 부분집합들을 모두 표현할 수 있음.
     - 꽉 찬 집합
       ```A = (1 << 10) - 1``` 
       ```
       1 << 10    // 00000000 00000000 00000100 00000000
       - 1        // 1의 보수
                  // 11111111 11111111 11111111 11111110
       --------------------------------------------------
                     11111111 11111111 11111111 11111111 (캐리 발생)
       ```
       - 캐리 발생 시, 캐리를 버리고 LSB(최하위 비트)에 1을 더해줌.
     - k 위치에 원소 추가
        ```A |= (1 << k)```
       ```
       1 << 8    // 00000000 00000000 00000001 00000000
       A         // 00000000 00000000 10001010 11111000
       |         // 00000000 00000000 10001011 11111000
       ```
     - k 위치의 원소 삭제
       ```A &= ~(1 << k)```
       ```
       ~(1 << 9)    // 11111111 11111111 11111101 11111111
       A            // 00000000 00000000 10001010 11111000
       &            // 00000000 00000000 10001000 11111000
       ```
   - 레퍼런스
     - (비트 이동 연산자, 비트 논리 연산자) https://coding-factory.tistory.com/521
     - (집합 구현) https://rebro.kr/63
     - (집합 구현) https://coding-food-court.tistory.com/193
     - (집합 구현) https://dev-nomad.com/38
     - (1의 보수와 2의 보수) https://ndb796.tistory.com/4
     - (캐리 발생) https://st-lab.tistory.com/189
3. 순열
   - 10819번 문제 
   - 재귀로 풀었으나 실행 시간이 412ms로 다른 사람들의 풀이에 비해 훨씬 오래 걸림. (10819_차이를 최대로.kt / 실행 시간: 412ms)
   - 그래서 다른 풀이를 참고해 다시 풂. (10819-other-1.kt / 실행 시간: 120ms) 
   - 레퍼런스
     - (재귀) https://bcp0109.tistory.com/236
     - (재귀) https://notepad96.tistory.com/entry/Kotlin-14
4. 백트래킹
5. BFS/DFS

### 외판원 순회 문제 (외판원순회: Travelling Salesman Problem) 
- 여러 도시들이 있고 한 도시에서 다른 도시로 이동하는 비용이 모두 주어졌을 때, 모든 도시들을 단 한 번만 방문하고 원래 시작점으로 돌아오는 최소 비용의 이동 순서를 구하는 문제 
- 한 정점에서 다른 모든 정점을 순회하여 다시 출발 정점으로 돌아오는 최적의 경로를 찾는 알고리즘으로, N개의 정점 중 어느 정점에서 탐색을 시작해도 결과는 동일함.
- 정점의 개수(N)이 16개 이하일 때, 비트마스킹과 메모제이션 기법을 사용하면 됨.
- 레퍼런스
  - https://withhamit.tistory.com/246
  - https://loosie.tistory.com/272

### 소수 판별법
- 에라토스테네스의 체
- 밀러-라빈 소수 판별법
- 레퍼런스
  - https://rebro.kr/46

<br>

## ETC
- 1476번 문제 코틀린 기준 2등!
  <img src="https://user-images.githubusercontent.com/52561963/161684296-825ea595-41a3-45f1-a8d3-fac262a99a40.png" width="400" />

- 1451번 문제 코틀린 기준 1등!!! 첫 제출에서는 Int형으로 max 값을 설정해서 틀렸다고 나왔지만 이를 수정해 성공! 코드 작성은 1시간 10분 정도 걸림.

  <img src="https://user-images.githubusercontent.com/52561963/163920592-c025ff5b-7bdd-4f8e-bc12-b09514ebc0f9.png" width="400" />