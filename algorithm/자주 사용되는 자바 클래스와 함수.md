# 기본 문법

---
## compareTo, compare






<br>
<br>

# 자료 구조

---
## Stack




<br>

## Queue




<br>

## PriorityQueue
### 선언 방법
```
import java.util.PriorityQueue;
import java.util.Collections;

// 낮은 숫자가 우선
PriorityQueue<Integer> pqLowest = new PriorityQueue<>();

// 높은 숫자 우선
PriorityQueue<Integer> pqLowest = new PriorityQueue<>(Collections.reverseOrder());
```

### 함수
- `add()`: 우선순위 큐에 원소 추가. 큐가 꽉 찬 경우 에러 발생.
- `offer()`: 우선순위 큐에 원소 추가. 큐가 꽉 찬 경우 false 반환.
- `poll()`: 우선순위 큐에서 첫 번째 값을 반환하고 제거. 비어 있으면 null 반환.
- `remove()`: 우선순위 큐에서 첫 번째 값을 반환하고 제거. 비어 있으면 에러 발생. 
- `isEmpty()`: 우선순위 큐에 원소가 존재하는지 체크.
- `clear()`: 우선순위 큐를 초기화.
- `size()`: 우선순위 큐에 포함된 원소의 개수를 반환.

### 사용자 정의 클래스 타입 사용
```java
class QueueNode implements Comparable<QueueNode> {
    private int index;
    private int distance;

    public QueueNode(int index, int distance) {
        this.index = index;
        this.distance = distance;
    }

    public int getIndex() {
        return this.index;
    }

    public int getDistance() {
        return this.distance;
    }

    // 거리(비용)가 짧은 것이 높은 우선순위를 가지도록 설정
    @Override
    public int compareTo(QueueNode other) {
        // return this.distance - other.distance로 축약할 수 있음.
        if (this.distance < other.distance) {
            return -1;
        } else if (this.distance > other.distance) {
          return 1;
        }
        return 0;
    }
}
```

### 참고
- https://velog.io/@gillog/Java-Priority-Queue%EC%9A%B0%EC%84%A0-%EC%88%9C%EC%9C%84-%ED%81%90


<br>

## Deque

큐의 양쪽으로 원소를 삽입하거나 삭제할 수 있는 자료 구조를 의미한다.

### 선언 방법
```
Deque<Integer> deque = new ArrayDeque<>();
Deque<String> deque = new LinkedList<>();
```


### 함수
- `addFirst()`: 덱의 앞에 원소를 삽입한다.
- `addLast()`: 덱의 마지막에 원소를 삽입한다.
- `poll()`/`pollFirst()`: 덱의 맨 앞에 있는 원소를 반환한다.
- `pollLast()`: 덱의 맨 뒤에 있는 원소를 반환한다.
- `peek()`/`peekFirst()`: 덱의 맨 앞에 있는 원소의 값을 반환한다(원소 제거 X).
- `peekLast()`: 덱의 맨 뒤에 있는 원소의 값을 반환한다(원소 제거 X).
> `peek()`, `peekFirst()`, `peekLast()`는 원소가 덱에 존재하지 않는 경우 NPE가 발생한다.

### 참고
- 10845번 문제
- https://soft.plusblog.co.kr/24

<br>